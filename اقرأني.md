# سيلينيوم

سيلينيوم هو مشروع شامل يضم مجموعة متنوعة من الأدوات والمكتبات التي تتيح التشغيل الآلي لمتصفح الويب.
يوفر السيلينيوم على وجه التحديد بنية أساسية لـ [مواصفات W3C WebDriver] منصة وواجهة ترميز محايدة للغة متوافقة مع جميع متصفحات الويب الرئيسية.

انجز المشروع بتبرعات سخية من قبل المساهمين المتطوعين الذين تبرعوا بسخاء بآلاف الساعات في تطوير 
التعليمات البرمجية لكود المصدر وصيانته في الفرع الرئيسي للمشروع  (https://github.com/SeleniumHQ).

كود المصدر لسيلينيوم متاح تحت رخصة اباتشي. [Apache 2.0 license](https://github.com/SeleniumHQ/selenium/blob/trunk/LICENSE).

هذه الشوكة للشرح والتدريب باللغة العربية للمهتمين.
بالنسبة للأشخاص الذين يتطلعون إلى البحث في الوثائق الاساسية لسيلينيوم، موجودة على الرابط التالي:
[وثائق سيلينيوم] (https://selenium.dev/documentation)


## التثبيت

هذه هي المتطلبات اللازمة لإنشاء بيئة التطوير المحلية الخاصة بك للمساهمة في السيلينيوم.### جميع المنصات
* [بازليسك](https://github.com/bazelbuild/bazelisk)،

غلاف بازل
الذي يقوم تلقائيًا بتنزيل إصدار بازل المحدد في ملف `.bazelversion` ويمرر بشفافية عبر جميع وسيطات سطر الأوامر إلى ثنائي بازل الحقيقي.

* إصدار Java JDK 17 أو أحدث (على سبيل المثال، [Java 17 Temurin](https://adoptium.net/temurin/releases/?version=17))
 * قم بتعيين متغير البيئة `JAVA_HOME` على موقع Java القابل للتنفيذ (JDK وليس JRE)
 * لاختبار ذلك، حاول تشغيل الأمر "javac". لن يكون هذا الأمر موجودًا إذا كان JRE مثبتًا لديك فقط. إذا وجدت قائمة من خيارات سطر الأوامر، فأنت تشير إلى JDK بشكل صحيح.

### ماك
* قم بتثبيت أحدث إصدار ل Xcode. بما في ذلك أدوات سطر الأوامر باستخدام: `xcode-select --install`
* لأجهزة Rosetta من Mac من Apple Silicon اضف: `بناء --host_platform=//:Rosetta`
إلى الملف : ".bazelrc.local".
### ويندوز.
هناك ثلاث خيارات ويندوز

#### الخيار 1: التثبيت التلقائي من الصفر
سيضمن هذا البرنامج النصي بيئة مطور جاهزة تمامًا للتنفيذ.
(لم يتم تثبيت أي شيء أو تعيينه موجود بالفعل ما لم يُطلب خلاف ذلك)

1. افتح Powershell كمسؤول
2. تنفيذ: `Set-ExecutionPolicy Bypass -Scope Process -Force` للسماح بتشغيل البرنامج النصي في العملية
3. انتقل إلى الدليل الذي تريد استنساخ سيلينيوم فيه، أو الدليل الأصلي لمستودع سيلينيوم المستنسخ بالفعل
4. قم بتنزيل وتنفيذ هذا البرنامج النصي في محطة باورشيل: [scripts/dev-environment-setup.ps1]`

#### الخيار 2: التثبيت اليدوي
1. السماح بتشغيل البرامج النصية في السيلينيوم بشكل عام:
 ```
 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned
 ```
2. تمكين وضع المطور:
 ```
 reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AppModelUnlock" /t REG_DWORD /f /v "AllowDevelopmentWithoutDevLicense" /d "1"
 ```
3. قم بتثبيت [MSYS2](https://www.msys2.org/)، وهي بيئة Shell بديلة توفر أوامر تشبه Unix
 * أضف دليل bin إلى متغير البيئة `PATH` (على سبيل المثال، `"C:\tools\msys64\usr\bin"`)
 * أضف موقع `bash.exe` كمتغير البيئة `BAZEL_SH` (على سبيل المثال، `"C:\tools\msys64\usr\bin\bash.exe"`)
4. قم بتثبيت أحدث إصدار من [Visual Studio Community](https://visualstudio.microsoft.com/vs/community/)
 * استخدم مثبت الاستوديو المرئي لتعديل عبء العمل "تطوير سطح المكتب باستخدام C++" وإضافته
 * أضف موقع دليل تثبيت أدوات إنشاء Visual C++ إلى متغير البيئة `BAZEL_VC` (على سبيل المثال، `"C:\Program Files\Microsoft Visual Studio\2022\Community\VC"`)
 * أضف إصدار أدوات Visual C++ Build إلى متغير البيئة `BAZEL_VC_FULL_VERSION` (يمكن اكتشاف ذلك من اسم الدليل في `"$BAZEL_VC\Tools\MSVC\<BAZEL_VC_FULL_VERSION>"`)
5. إضافة دعم لأسماء الملفات الطويلة (يحتوي bzel على الكثير من الدلائل المتداخلة التي يمكن أن تتجاوز الحدود الافتراضية في Windows)
 * تمكين دعم المسارات الطويلة باستخدام أمري التسجيل هذين:
 ```shell
 reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor" /t REG_DWORD /f /v "DisableUNCCheck" /d "1"
 reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem" /t REG_DWORD /f /v "LongPathsEnabled" /d "1"
 ```
 * السماح لـ Bazel بإنشاء إصدارات ذات أسماء قصيرة لمسارات الملفات الطويلة: `fsutil 8dot3name set 0`
 * قم بتعيين إخراج bazel على `C:/tmp` بدلاً من تضمينه داخل دليل المشروع:
 * قم بإنشاء ملف "selenium/.bazelrc.windows.local".
 * أضف "بدء التشغيل --output_user_root=C:/tmp" إلى الملف

### بيئات التطوير البديلة

إذا كنت ترغب في المساهمة في المشروع، ولكنك لا ترغب في إعداد بيئة التطوير المحلية الخاصة بك،
هناك نوعان من البدائل المتاحة.

#### استخدام GitPod

بدلاً من إنشاء بيئة التطوير المحلية الخاصة بك، يوفر لك GitPod بيئة جاهزة للاستخدام.

[![فتح في Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/SeleniumHQ/selenium)

#### استخدام حاوية التطوير

كبديل، يمكنك إنشاء [Dev Container](https://containers.dev/) 
وهي مناسبة لبناء السيلينيوم واختباره باستخدام devcontainer.json في ملف
دليل [.devcontainer](.devcontainer/devcontainer.json). دعم IDEs مثل VS Code أو IntelliJ IDEA
يجب أن يوجهك إلى كيفية إنشاء مثل هذه الحاوية.

#### استخدام صورة Docker عامل الميناء

يمكنك أيضًا إنشاء صورة Docker مناسبة
لبناء سيلينيوم واختباره باستخدام ملف Dockerfile في ملف
دليل [dev image] (scripts/dev-image/Dockerfile).
## Building

Selenium is built using a common build tool called [Bazel](https://bazel.build/), to
allow us to easily manage dependency downloads, generate required binaries, build and release packages, and execute tests;
all in a fast, efficient manner. For a more detailed discussion, read Simon Stewart's article on [Building Selenium](https://www.selenium.dev/blog/2023/building-selenium/)

Often we wrap Bazel commands with our custom [Rake](http://rake.rubyforge.org/) wrapper. These are run with the `./go` command.

The common Bazel commands are:
* `bazel build` — evaluates dependencies, compiles source files and generates output files for the specified target.
It's used to create executable binaries, libraries, or other artifacts.
* `bazel run` — builds the target and then executes it.
It's typically used for targets that produce executable binaries.
* `bazel test` — builds and runs the target in a context with additional testing functionality
* `bazel query` — identifies available targets for the provided path.

Each module that can be built is defined in a `BUILD.bazel` file. To execute the module you refer to it starting with a
`//`, then include the relative path to the file that defines it, then `:`, then the name of the target.
For example, the target to build the Grid is named `executable-grid` and it is
defined in the `'selenium/java/src/org/openqa/selenium/grid/BAZEL.build'` file.
So to build the grid you would run: `bazel build //java/src/org/openqa/selenium/grid:executable-grid`.

The Bazel documentation has a [handy guide](https://bazel.build/run/build#specifying-build-targets)
for various shortcuts and all the ways to build multiple targets, which Selenium makes frequent use of.

To build everything for a given language:
```shell
bazel build //<language>/...
```

To build just the grid there is an alias name to use (the log will show where the output jar is located):
```sh
bazel build grid
```

To make things more simple, building each of the bindings is available with this `./go` command
```shell
./go <language>:build
```


## Developing

### Java

#### IntelliJ
Most of the team uses Intellij for their day-to-day editing. If you're
working in IntelliJ, then we highly recommend installing the [Bazel IJ
plugin](https://plugins.jetbrains.com/plugin/8609-bazel) which is documented on
[its own site](https://plugins.jetbrains.com/plugin/8609-bazel).

To use Selenium with the IntelliJ Bazel plugin, import the repository as a Bazel project, and select the project
view file from the [scripts](scripts) directory. `ij.bazelproject` for Mac/Linux and `ij-win.bazelproject` for Windows.

#### Linting
We also use Google Java Format for linting, so using the Google Java Formatter Plugin is useful;
there are a few steps to get it working, so read their [configuration documentation](https://github.com/google/google-java-format/blob/master/README.md#intellij-jre-config).
There is also an auto-formatting script that can be run: `./scripts/format.sh`

#### Local Installation
While Selenium is not built with Maven, you can build and install the Selenium pieces
for Maven to use locally by deploying to your local maven repository (`~/.m2/repository`), using:
```shell
./go java:install
```

#### Updating Dependencies

Dependencies are defined in the file [maven_deps.bzl](https://github.com/SeleniumHQ/selenium/blob/trunk/java/maven_deps.bzl).
To automatically update and pin new dependencies, run:

```shell
./go java:update
```

### Python

You can run Python code locally by updating generated files in the python directory using:
```shell
./go py:update
```

To install Selenium locally based on a specific commit, you can use:
```shell
./go py:install
```

### Ruby

Instead of using `irb`, you can create an interactive REPL with all gems loaded using: `bazel run //rb:console`

If you want to debug code, you can do it via [`debug`](https://github.com/ruby/debug) gem:
1. Add `binding.break` to the code where you want the debugger to start.
2. Run tests with  `ruby_debug` configuration: `bazel test --config ruby_debug <test>`.
3. When debugger starts, run the following in a separate terminal to connect to debugger:

```sh
bazel-selenium/external/bundle/bin/rdbg -A
```

If you want to use [RubyMine](https://www.jetbrains.com/ruby/) for development,
you can configure it use Bazel artifacts:

1. Open `rb/` as a main project directory.
2. Run `bundle exec rake update` as necessary to create up-to-date artifacts. If this does not work, run `./go rb:update` from the `selenium` (parent) directory.
3. In <kbd>Settings / Languages & Frameworks / Ruby SDK and Gems</kbd> add new <kbd>Interpreter</kbd> pointing to `../bazel-selenium/external/rules_ruby_dist/dist/bin/ruby`.
4. You should now be able to run and debug any spec. It uses Chrome by default, but you can alter it using environment variables secified in [Ruby Testing](#ruby-2) section below.

### Rust

To keep `Carbo.Bazel.lock` synchronized with `Cargo.lock`, run:
```shell
CARGO_BAZEL_REPIN=true bazel sync --only=crates
```


## Testing

There are a number of bazel configurations specific for testing.

### Common Options Examples

Here are examples of arguments we make use of in testing the Selenium code:
* `--pin_browsers` - run specific browser versions defined in the build (versions are updated regularly)
* `--headless` - run browsers in headless mode (supported be Chrome, Edge and Firefox)
* `--flaky_test_attempts 3` - re-run failed tests up to 3 times
* `--local_test_jobs 1` - control parallelism of tests
* `--cache_test_results=no`, `-t-` - disable caching of test results and re-runs all of them
* `--test_output all` - print all output from the tests, not just errors
* `--test_output streamed` - run all tests one by one and print its output immediately
* `--test_env FOO=bar` - pass extra environment variable to test process
* `--run_under="xvfb-run -a"` - prefix to insert before the execution

### Filtering

Selenium tests can be filtered by size:
* small — typically unit tests where no browser is opened
* large — typically tests that actually drive a browser
* medium — tests that are more involved than simple unit tests, but not fully driving a browser

These can be filtered using the `test_size_filters` argument like this:
```sh
bazel test //<language>/... --test_size_filters=small
```

Tests can also be filtered by tag like:
```sh
bazel test //<language>/... --test_tag_filters=this,-not-this
```

### Java

<details>
<summary>Click to see Java Test Commands</summary>

To run unit tests:
```shell
bazel test //java/... --test_size_filters=small
```
To run integration tests:
```shell
bazel test //java/... --test_size_filters=medium
```
To run browser tests:
```shell
bazel test //java/... --test_size_filters=large --test_tag_filters=<browser>
```

To run a specific test:
```shell
bazel test //java/test/org/openqa/selenium/chrome:ChromeDriverFunctionalTest
```

</details>

### JavaScript
<details>
<summary>Click to see JavaScript Test Commands</summary>

To run the tests run:

```sh
bazel test //javascript/node/selenium-webdriver:tests
```

You can use `--test_env` to pass in the browser name as `SELENIUM_BROWSER`.

```sh
bazel test //javascript/node/selenium-webdriver:tests --test_env=SELENIUM_BROWSER=firefox
```

</details>

### Python
<details>
<summary>Click to see Python Test Commands</summary>

Run unit tests with:
```shell
bazel test //py:unit
```

To run tests with a specific browser:

```sh
bazel test //py:test-<browsername>
```

To run all Python tests:
```shell
bazel test //py:all
```

</details>

### Ruby
<details>
<summary>Click to see Ruby Test Commands</summary>

Test targets:

| Command                                                                          | Description                                        |
| -------------------------------------------------------------------------------- | -------------------------------------------------- |
| `bazel test //rb/...`                                                            | Run unit, all integration tests and lint           |
| `bazel test //rb:lint`                                                           | Run RuboCop linter                                 |
| `bazel test //rb/spec/...`                                                       | Run unit and integration tests for all browsers    |
| `bazel test //rb/spec/... --test_size_filters small`                             | Run unit tests                                     |
| `bazel test //rb/spec/unit/...`                                                  | Run unit tests                                     |
| `bazel test //rb/spec/... --test_size_filters large`                             | Run integration tests for all browsers             |
| `bazel test //rb/spec/integration/...`                                           | Run integration tests for all browsers             |
| `bazel test //rb/spec/integration/... --test_tag_filters firefox`                | Run integration tests for local Firefox only       |
| `bazel test //rb/spec/integration/... --test_tag_filters firefox-remote`         | Run integration tests for remote Firefox only      |
| `bazel test //rb/spec/integration/... --test_tag_filters firefox,firefox-remote` | Run integration tests for local and remote Firefox |

Ruby test targets have the same name as the spec file with `_spec.rb` removed, so you can run them individually.
Integration tests targets also have a browser and remote suffix to control which browser to pick and whether to use Grid.

| Test file                                               | Test target                                                      |
| ------------------------------------------------------- | ---------------------------------------------------------------- |
| `rb/spec/unit/selenium/webdriver/proxy_spec.rb`         | `//rb/spec/unit/selenium/webdriver:proxy`                        |
| `rb/spec/integration/selenium/webdriver/driver_spec.rb` | `//rb/spec/integration/selenium/webdriver:driver-chrome`         |
| `rb/spec/integration/selenium/webdriver/driver_spec.rb` | `//rb/spec/integration/selenium/webdriver:driver-chrome-remote`  |
| `rb/spec/integration/selenium/webdriver/driver_spec.rb` | `//rb/spec/integration/selenium/webdriver:driver-firefox`        |
| `rb/spec/integration/selenium/webdriver/driver_spec.rb` | `//rb/spec/integration/selenium/webdriver:driver-firefox-remote` |

Supported browsers:

* `chrome`
* `edge`
* `firefox`
* `firefox-beta`
* `ie`
* `safari`
* `safari-preview`

In addition to the [Common Options Examples](#common-options-examples), here are some additional Ruby specific ones:
* `--test_arg "-eTimeouts"` - test only specs which name include "Timeouts"
* `--test_arg "<any other RSpec argument>"` - pass any extra RSpec arguments (see `bazel run @bundle//bin:rspec -- --help`)

Supported environment variables for use with `--test_env`:

- `WD_SPEC_DRIVER` - the driver to test; either the browser name or 'remote' (gets set by Bazel)
- `WD_REMOTE_BROWSER` - when `WD_SPEC_DRIVER` is `remote`; the name of the browser to test (gets set by Bazel)
- `WD_REMOTE_URL` - URL of an already running server to use for remote tests
- `DOWNLOAD_SERVER` - when `WD_REMOTE_URL` not set; whether to download and use most recently released server version for remote tests
- `DEBUG` - turns on verbose debugging
- `HEADLESS` - for chrome, edge and firefox; runs tests in headless mode
- `DISABLE_BUILD_CHECK` - for chrome and edge; whether to ignore driver and browser version mismatches (allows testing Canary builds)
- `CHROME_BINARY` - path to test specific Chrome browser
- `CHROMEDRIVER_BINARY` - path to test specific ChromeDriver
- `EDGE_BINARY` - path to test specific Edge browser
- `MSEDGEDRIVER_BINARY` - path to test specific msedgedriver
- `FIREFOX_BINARY` - path to test specific Firefox browser
- `GECKODRIVER_BINARY` - path to test specific GeckoDriver

To run with a specific version of Ruby you can change the version in `rb/.ruby-version` or from command line:

```sh
echo '<X.Y.Z>' > rb/.ruby-version
```
</details>

### .NET
<details>
<summary>Click to see .NET Test Commands</summary>

.NET tests currently only work with pinned browsers, so make sure to include that.

Run all tests with:
```sh
bazel test //dotnet/test/common:AllTests --pin_browsers=true
```

You can run specific tests by specifying the class name:
```shell
bazel test //dotnet/test/common:ElementFindingTest --pin_browsers=true
```

If the module supports multiple browsers:
```shell
bazel test //dotnet/test/common:ElementFindingTest-edge --pin_browsers=true
```

</details>

### Rust
<details>
<summary>Click to see Rust Test Commands</summary>

Rust tests are run with:

```shell
bazel test //rust/...
```
</details>

### Linux

<details>
<summary>Click to see Linux Testing Requirements</summary>

By default, Bazel runs these tests in your current X-server UI. If you prefer, you can
alternatively run them in a virtual or nested X-server.

1. Run the X server `Xvfb :99` or `Xnest :99`
2. Run a window manager, for example, `DISPLAY=:99 jwm`
3. Run the tests you are interested in:
```sh
bazel test --test_env=DISPLAY=:99 //java/... --test_tag_filters=chrome
```

An easy way to run tests in a virtual X-server is to use Bazel's `--run_under`
functionality:
```
bazel test --run_under="xvfb-run -a" //java/...
```
</details>


## Documenting

API documentation can be found here:

* [C#](https://seleniumhq.github.io/selenium/docs/api/dotnet/)
* [JavaScript](https://seleniumhq.github.io/selenium/docs/api/javascript/)
* [Java](https://seleniumhq.github.io/selenium/docs/api/java/index.html)
* [Python](https://seleniumhq.github.io/selenium/docs/api/py/)
* [Ruby](https://seleniumhq.github.io/selenium/docs/api/rb/)

To update API documentation for a specific language: `./go <language>:docs`

To update all documentation: `./go all:docs`

Note that JavaScript generation is [currently broken](https://github.com/SeleniumHQ/selenium/issues/10185).


## Releasing

The full process for doing a release can be found in [the wiki](https://github.com/SeleniumHQ/selenium/wiki/Releasing-Selenium)

Releasing is a combination of building and publishing, which often requires coordination of multiple executions
and additional processing.
As discussed in the [Building](#building) section, we use Rake tasks with the `./go` command for these things.
These `./go` commands include the `--stamp` argument to provide necessary information about the constructed asset.

You can build and release everything with:
```shell
./go all:release
```

To build and release a specific language:
```shell
./go <language>:release
```

If you have access to the Selenium EngFlow repository, you can have the assets built remotely and downloaded locally using:
```shell
./go all:release['--config', 'release']
```
